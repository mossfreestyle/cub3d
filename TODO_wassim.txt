CUB3D - ROADMAP BACKEND DÃ‰TAILLÃ‰E
=================================

ğŸ“‹ TABLE DES MATIÃˆRES
=====================
1. SETUP INITIAL DU PROJET
2. STRUCTURES DE DONNÃ‰ES
3. PARSING ET VALIDATION
4. MOTEUR RAYCASTING
5. GESTION JOUEUR
6. OPTIMISATIONS
7. TESTS ET DEBUG
8. BONUS (SI TEMPS)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. SETUP INITIAL DU PROJET
===========================

1.1 STRUCTURE DES DOSSIERS
---------------------------
cub3d/
â”œâ”€â”€ Makefile
â”œâ”€â”€ includes/
â”‚   â””â”€â”€ cub3d.h
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.c
â”‚   â”œâ”€â”€ parsing/
â”‚   â”‚   â”œâ”€â”€ parser.c
â”‚   â”‚   â”œâ”€â”€ map_validator.c
â”‚   â”‚   â”œâ”€â”€ texture_loader.c
â”‚   â”‚   â””â”€â”€ color_parser.c
â”‚   â”œâ”€â”€ raycasting/
â”‚   â”‚   â”œâ”€â”€ raycasting.c
â”‚   â”‚   â”œâ”€â”€ ray_utils.c
â”‚   â”‚   â”œâ”€â”€ dda_algorithm.c
â”‚   â”‚   â””â”€â”€ wall_detection.c
â”‚   â”œâ”€â”€ player/
â”‚   â”‚   â”œâ”€â”€ player_init.c
â”‚   â”‚   â”œâ”€â”€ movement.c
â”‚   â”‚   â”œâ”€â”€ rotation.c
â”‚   â”‚   â””â”€â”€ collision.c
â”‚   â”œâ”€â”€ rendering/
â”‚   â”‚   â”œâ”€â”€ texture_mapping.c
â”‚   â”‚   â”œâ”€â”€ drawing.c
â”‚   â”‚   â””â”€â”€ color_utils.c
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ math_utils.c
â”‚       â”œâ”€â”€ memory_manager.c
â”‚       â”œâ”€â”€ error_handler.c
â”‚       â””â”€â”€ cleanup.c
â”œâ”€â”€ textures/
â”œâ”€â”€ maps/
â””â”€â”€ libft/ (si autorisÃ©)

1.2 MAKEFILE CONFIGURATION
---------------------------
- Compiler avec gcc
- Flags: -Wall -Wextra -Werror
- Lier avec MinilibX (-lmlx -lXext -lX11 -lm)
- RÃ¨gles: all, clean, fclean, re
- Variables: NAME, SRCS, OBJS, CC, CFLAGS

1.3 HEADER PRINCIPAL (cub3d.h)
-------------------------------
- Inclusions systÃ¨me (#include <math.h>, <fcntl.h>, etc.)
- Inclusion MinilibX
- DÃ©finition des constantes (largeur/hauteur fenÃªtre, vitesses)
- DÃ©claration de toutes les structures
- Prototypes de toutes les fonctions

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

2. STRUCTURES DE DONNÃ‰ES
=========================

2.1 STRUCTURE PRINCIPALE DU JEU
--------------------------------
typedef struct s_game {
    void        *mlx;           // Pointeur MLX
    void        *win;           // FenÃªtre
    void        *img;           // Image buffer
    char        *addr;          // Adresse pixel data
    int         bits_per_pixel; // Bits par pixel
    int         line_length;    // Longueur ligne
    int         endian;         // Endianness
    t_map       *map;           // DonnÃ©es carte
    t_player    *player;        // DonnÃ©es joueur
    t_texture   *textures;      // Textures chargÃ©es
    int         keys[256];      // Ã‰tat des touches
} t_game;

2.2 STRUCTURE CARTE
-------------------
typedef struct s_map {
    char    **grid;             // Grille 2D (malloc'd)
    int     width;              // Largeur
    int     height;             // Hauteur
    char    *north_texture;     // Chemin texture N
    char    *south_texture;     // Chemin texture S
    char    *west_texture;      // Chemin texture W
    char    *east_texture;      // Chemin texture E
    int     floor_color;        // RGB sol
    int     ceiling_color;      // RGB plafond
    int     player_start_x;     // Position initiale X
    int     player_start_y;     // Position initiale Y
    char    player_direction;   // Direction initiale (N/S/E/W)
} t_map;

2.3 STRUCTURE JOUEUR
--------------------
typedef struct s_player {
    double  x;                  // Position X (coordonnÃ©es monde)
    double  y;                  // Position Y
    double  dir_x;              // Vecteur direction X
    double  dir_y;              // Vecteur direction Y
    double  plane_x;            // Plan camÃ©ra X
    double  plane_y;            // Plan camÃ©ra Y
    double  move_speed;         // Vitesse dÃ©placement
    double  rot_speed;          // Vitesse rotation
} t_player;

2.4 STRUCTURE RAYON
-------------------
typedef struct s_ray {
    double  camera_x;           // Position sur plan camÃ©ra [-1, 1]
    double  ray_dir_x;          // Direction rayon X
    double  ray_dir_y;          // Direction rayon Y
    int     map_x;              // Case carte X
    int     map_y;              // Case carte Y
    double  side_dist_x;        // Distance au prochain cÃ´tÃ© X
    double  side_dist_y;        // Distance au prochain cÃ´tÃ© Y
    double  delta_dist_x;       // Distance entre intersections X
    double  delta_dist_y;       // Distance entre intersections Y
    double  perp_wall_dist;     // Distance perpendiculaire mur
    int     step_x;             // Direction pas X (-1 ou 1)
    int     step_y;             // Direction pas Y (-1 ou 1)
    int     hit;                // Mur touchÃ© (0/1)
    int     side;               // CÃ´tÃ© mur (0=NS, 1=EW)
    int     line_height;        // Hauteur ligne Ã  dessiner
    int     draw_start;         // Pixel dÃ©but dessin
    int     draw_end;           // Pixel fin dessin
} t_ray;

2.5 STRUCTURE TEXTURE
---------------------
typedef struct s_texture {
    void    *img;               // Image MLX
    char    *addr;              // Adresse donnÃ©es
    int     width;              // Largeur texture
    int     height;             // Hauteur texture
    int     bits_per_pixel;     // Bits par pixel
    int     line_length;        // Longueur ligne
    int     endian;             // Endianness
} t_texture;

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

3. PARSING ET VALIDATION
=========================

3.1 PARSER PRINCIPAL (parser.c)
-------------------------------
FONCTION: parse_cub_file(char *filename, t_map *map)
Ã‰TAPES:
1. Ouvrir fichier .cub
2. Lire ligne par ligne
3. Identifier type de ligne (texture/couleur/carte)
4. Appeler parser spÃ©cialisÃ©
5. Valider complÃ©tude des donnÃ©es
6. Fermer fichier

DÃ‰TAILS TECHNIQUES:
- Utiliser get_next_line ou read() + buffer
- Ignorer lignes vides et commentaires
- VÃ©rifier extension .cub
- GÃ©rer erreurs ouverture fichier

3.2 VALIDATION CARTE (map_validator.c)
--------------------------------------
FONCTION: validate_map(t_map *map)
VALIDATIONS REQUISES:
1. Carte entourÃ©e de murs ('1')
2. CaractÃ¨res valides uniquement ('0', '1', 'N', 'S', 'E', 'W', ' ')
3. Un seul point de dÃ©part joueur
4. Pas de trous dans les murs
5. Carte rectangulaire (remplir espaces avec ' ')

ALGORITHME FLOOD FILL:
- Partir de la position joueur
- Marquer toutes cases '0' accessibles
- VÃ©rifier qu'aucune case marquÃ©e touche bord/espace

3.3 CHARGEUR TEXTURES (texture_loader.c)
----------------------------------------
FONCTION: load_texture(char *path, t_texture *texture)
Ã‰TAPES:
1. VÃ©rifier existence fichier
2. Charger avec mlx_xpm_file_to_image()
3. RÃ©cupÃ©rer adresse donnÃ©es avec mlx_get_data_addr()
4. Stocker dimensions et mÃ©tadonnÃ©es
5. GÃ©rer erreurs chargement

VALIDATIONS:
- Extensions autorisÃ©es (.xpm)
- Taille texture raisonnable
- Format image valide

3.4 PARSER COULEURS (color_parser.c)
------------------------------------
FONCTION: parse_color(char *line, int *color)
FORMAT ATTENDU: "F 220,100,0" ou "C 225,30,0"
Ã‰TAPES:
1. Extraire valeurs R,G,B
2. VÃ©rifier plage [0,255]
3. Convertir en entier RGB (R << 16 | G << 8 | B)
4. GÃ©rer erreurs format

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

4. MOTEUR RAYCASTING
====================

4.1 BOUCLE PRINCIPALE (raycasting.c)
------------------------------------
FONCTION: cast_rays(t_game *game)
POUR CHAQUE COLONNE X (0 Ã  SCREEN_WIDTH-1):
1. Calculer camera_x = 2 * x / (double)SCREEN_WIDTH - 1
2. Calculer direction rayon
3. Initialiser variables DDA
4. ExÃ©cuter algorithme DDA
5. Calculer distance et hauteur mur
6. Dessiner colonne de pixels

OPTIMISATION:
- PrÃ©-calculer certaines valeurs
- Utiliser lookup tables pour trigonomÃ©trie
- Minimiser allocations mÃ©moire

4.2 ALGORITHME DDA (dda_algorithm.c)
------------------------------------
FONCTION: perform_dda(t_game *game, t_ray *ray)
INITIALISATION:
1. Calculer delta_dist_x = |1/ray_dir_x|
2. Calculer delta_dist_y = |1/ray_dir_y|
3. DÃ©terminer step et side_dist initiales

BOUCLE DDA:
while (ray->hit == 0) {
    if (side_dist_x < side_dist_y) {
        side_dist_x += delta_dist_x;
        map_x += step_x;
        side = 0;
    } else {
        side_dist_y += delta_dist_y;
        map_y += step_y;
        side = 1;
    }
    if (map[map_x][map_y] == '1') hit = 1;
}

4.3 CALCULS GÃ‰OMÃ‰TRIQUES (ray_utils.c)
--------------------------------------
FONCTION: calculate_wall_distance(t_ray *ray, t_player *player)
- Calculer distance perpendiculaire au mur
- Ã‰viter effet "fisheye"
- Calculer hauteur ligne Ã  dessiner
- DÃ©terminer pixels dÃ©but/fin

FONCTION: calculate_texture_coordinates(t_ray *ray, t_player *player)
- DÃ©terminer quelle texture utiliser (N/S/E/W)
- Calculer coordonnÃ©e X sur la texture
- GÃ©rer cas oÃ¹ rayon frappe cÃ´tÃ© ou face

4.4 DÃ‰TECTION MURS (wall_detection.c)
-------------------------------------
FONCTION: is_wall(t_map *map, int x, int y)
- VÃ©rifier limites carte
- Retourner 1 si '1', 0 sinon
- GÃ©rer espaces comme murs pour sÃ©curitÃ©

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

5. GESTION JOUEUR
=================

5.1 INITIALISATION (player_init.c)
----------------------------------
FONCTION: init_player(t_map *map, t_player *player)
Ã‰TAPES:
1. Trouver position joueur sur carte (N/S/E/W)
2. DÃ©finir position initiale (centre de la case)
3. DÃ©finir vecteur direction selon orientation
4. DÃ©finir plan camÃ©ra (perpendiculaire Ã  direction)
5. DÃ©finir vitesses mouvement/rotation

ORIENTATIONS INITIALES:
- N: dir(-1,0), plane(0,0.66)
- S: dir(1,0), plane(0,-0.66)
- E: dir(0,1), plane(0.66,0)
- W: dir(0,-1), plane(-0.66,0)

5.2 SYSTÃˆME MOUVEMENT (movement.c)
----------------------------------
FONCTION: handle_movement(t_game *game)
TOUCHES WSAD:
- W: avancer (direction actuelle)
- S: reculer (direction opposÃ©e)
- A: strafe gauche (perpendiculaire gauche)
- D: strafe droite (perpendiculaire droite)

CALCULS:
new_x = player->x + dir_x * move_speed * delta_time
new_y = player->y + dir_y * move_speed * delta_time

VÃ‰RIFICATIONS:
- Collision avec murs
- Limites carte
- Vitesse frame-indÃ©pendante

5.3 SYSTÃˆME ROTATION (rotation.c)
---------------------------------
FONCTION: handle_rotation(t_game *game)
TOUCHES FLÃˆCHES:
- Gauche: rotation sens antihoraire
- Droite: rotation sens horaire

ROTATION MATRICIELLE:
old_dir_x = player->dir_x
player->dir_x = dir_x * cos(rot_speed) - dir_y * sin(rot_speed)
player->dir_y = old_dir_x * sin(rot_speed) + dir_y * cos(rot_speed)

old_plane_x = player->plane_x
player->plane_x = plane_x * cos(rot_speed) - plane_y * sin(rot_speed)
player->plane_y = old_plane_x * sin(rot_speed) + plane_y * cos(rot_speed)

5.4 DÃ‰TECTION COLLISION (collision.c)
-------------------------------------
FONCTION: check_collision(t_map *map, double x, double y)
VÃ‰RIFICATIONS:
1. Position dans limites carte
2. Case destination n'est pas mur
3. Buffer sÃ©curitÃ© autour joueur (0.1 unitÃ©)

FONCTION: can_move_to(t_map *map, double x, double y)
- Tester 4 coins du joueur (hitbox carrÃ©e)
- Retourner 0 si collision, 1 si libre

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

6. OPTIMISATIONS
================

6.1 OPTIMISATIONS MATHÃ‰MATIQUES
-------------------------------
LOOKUP TABLES:
- PrÃ©calculer sin/cos pour rotations communes
- Table distances pour Ã©viter sqrt()
- Cache rÃ©sultats calculs coÃ»teux

ARITHMÃ‰TIQUE ENTIÃˆRE:
- Utiliser fixed-point quand possible
- Ã‰viter divisions par multiplications inverses
- Optimiser boucles critiques

6.2 OPTIMISATIONS MÃ‰MOIRE
-------------------------
POOLS MÃ‰MOIRE:
- PrÃ©-allouer structures rayons
- RÃ©utiliser buffers temporaires
- Minimiser malloc/free en runtime

CACHE EFFICIENCY:
- Structures alignÃ©es mÃ©moire
- AccÃ¨s sÃ©quentiels aux textures
- LocalitÃ© spatiale donnÃ©es

6.3 OPTIMISATIONS RENDU
-----------------------
CULLING:
- Ne pas calculer rayons hors Ã©cran
- Skip pixels transparents
- Optimiser boucles dessin

FRAME TIMING:
- Target 60 FPS
- Delta time pour mouvements fluides
- Limiter recalculs inutiles

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

7. TESTS ET DEBUG
=================

7.1 TESTS UNITAIRES
-------------------
PARSER:
- Fichiers .cub valides/invalides
- Cartes avec erreurs diverses
- Textures manquantes/corrompues
- Couleurs hors limites

RAYCASTING:
- PrÃ©cision calculs DDA
- Gestion cas limites (coins)
- Performance grandes cartes
- MÃ©moire (valgrind)

7.2 OUTILS DEBUG
----------------
DEBUG VISUEL:
- Affichage minimap 2D
- Rayons visibles
- Position/direction joueur
- FPS counter

DEBUG CONSOLE:
- Logs dÃ©taillÃ©s parsing
- Ã‰tat interne structures
- Profiling performance
- DÃ©tection fuites mÃ©moire

7.3 GESTION ERREURS
-------------------
TYPES ERREURS:
- "Error\nInvalid map format"
- "Error\nTexture file not found"
- "Error\nInvalid color format"
- "Error\nMap not enclosed"

CLEANUP:
- LibÃ©rer toute mÃ©moire allouÃ©e
- Fermer fichiers ouverts
- DÃ©truire images MLX
- Exit propre

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

8. BONUS (SI TEMPS)
===================

8.1 AMÃ‰LIORATIONS VISUELLES
---------------------------
- Sprites 2D (objets, ennemis)
- Animation textures
- Effets de lumiÃ¨re
- Shadows/fog

8.2 GAMEPLAY
------------
- Collision sprites
- Portes ouvrables
- Son spatial
- Minimapa temps rÃ©el

8.3 OPTIMISATIONS AVANCÃ‰ES
--------------------------
- Multi-threading raycasting
- Frustum culling
- Level-of-detail textures
- Compression carte

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ NOTES IMPORTANTES
====================

NORMINETTE:
- Maximum 25 lignes par fonction
- Maximum 80 colonnes
- Noms variables/fonctions explicites
- Commentaires si nÃ©cessaire

PERFORMANCE TARGETS:
- 60 FPS constant
- < 16ms par frame
- MÃ©moire stable (pas de leaks)
- Responsive aux inputs

GESTION ERREURS:
- Toujours vÃ©rifier retours malloc
- GÃ©rer tous cas d'erreur fichier
- Messages erreur explicites
- Cleanup complet avant exit

TESTS OBLIGATOIRES:
- Cartes minimales (3x3)
- Cartes complexes
- Formats invalides
- Textures manquantes
- Limites systÃ¨me

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Ce document couvre TOUT ce que tu dois implÃ©menter pour la partie backend.
Imprime-le et coche chaque item au fur et Ã  mesure !

Bon courage !